# طرح کلی پروژه: بازی داستانی مبتنی بر هوش مصنوعی

این فایل به عنوان مستند اصلی و نقشه راه برای توسعه اپلیکیشن بازی داستانی عمل می‌کند. این سند شامل نمای کلی، ویژگی‌های پیاده‌سازی شده و برنامه توسعه برای قابلیت‌های جدید است.

---

## ۱. نمای کلی پروژه

این پروژه یک بازی نقش‌آفرینی متنی (Text-based RPG) است که داستان آن به صورت پویا و تعاملی توسط یک مدل زبان بزرگ (LLM) ساخته می‌شود. بازیکن با انتخاب گزینه‌های مختلف، داستان را پیش می‌برد و وضعیت شخصیت او (مانند سلامتی، گرسنگی و غیره) تحت تأثیر این انتخاب‌ها قرار می‌گیرد. هدف، ایجاد یک تجربه داستانی بی‌پایان، شخصی‌سازی شده و جذاب است.

## ۲. ویژگی‌های پیاده‌سازی شده (تا به امروز)

- **ساختار اصلی برنامه:**
  - ناوبری سه‌-تبی (Bottom Navigation Bar) شامل: بازی، کوله‌پشتی و سیستم.
  - استفاده از مدیریت وضعیت `flutter_riverpod` برای جداسازی منطق از رابط کاربری.

- **صفحه بازی (Game Screen):**
  - نمایش متن داستان تولید شده توسط هوش مصنوعی.
  - نمایش گزینه‌های قابل انتخاب برای بازیکن.
  - نمایش وضعیت‌های حیاتی بازیکن (سلامتی، سلامت روان، گرسنگی، انرژی).
  - قابلیت **سوال از راوی (Ask Narrator):** بازیکن می‌تواند بازی را متوقف کرده و سوالی را مستقیماً از راوی بپرسد.
  - **لودینگ هوشمند:** نمایش یک نشانگر لودینگ در زمانی که هوش مصنوعی در حال تولید ادامه داستان است.

- **سیستم هوش مصنوعی (AI Core):**
  - اتصال به API ابری (در حال حاضر `google_generative_ai`) برای تولید محتوای داستانی.
  - سیستم پرامپت (System Prompt) دقیق برای هدایت مدل به سمت تولید خروجی JSON با ساختار مشخص.
  - مدیریت تاریخچه مکالمه برای حفظ زمینه داستان.
  - مکانیزم خلاصه‌سازی تاریخچه برای جلوگیری از طولانی شدن بیش از حد و کاهش هزینه توکن.

- **ویژگی‌های تعاملی:**
  - **تبدیل متن به گفتار (TTS):** یک دکمه برای خواندن متن داستان با صدای بلند.
  - **تشخیص گفتار (STT):** قابلیت دادن فرمان صوتی به جای کلیک روی گزینه‌ها.

- **صفحه کوله‌پشتی و ساخت‌وساز (Inventory & Crafting):**
  - نمایش آیتم‌هایی که بازیکن در طول بازی جمع‌آوری کرده است.
  - قابلیت انتخاب دو آیتم و **ترکیب (Crafting)** آن‌ها برای ساخت یک آیتم جدید.
  - منطق ساخت‌وساز نیز توسط هوش مصنوعی مدیریت می‌شود.

- **صفحه سیستم (Save/Load):**
  - قابلیت **ذخیره کردن** وضعیت فعلی بازی (داستان، وضعیت بازیکن، آیتم‌ها) در یک اسلات جدید.
  - قابلیت **بارگذاری** یک بازی ذخیره شده.
  - قابلیت بازنویسی (Overwrite) و حذف اسلات‌های ذخیره.
  - استفاده از پایگاه داده محلی `Isar` برای ذخیره‌سازی داده‌ها روی دستگاه.

- **کیفیت کد:**
  - استفاده از کامنت‌های فارسی در سراسر کد برای درک بهتر.
  - رفع تمام خطاها و هشدارهای `dart analyze`.
  - فرمت‌بندی استاندارد کد.

---

## ۳. برنامه توسعه فعلی: سیستم هوش مصنوعی دوگانه (محلی و ابری)

**هدف:** ایجاد یک سیستم انعطاف‌پذیر که به کاربر اجازه می‌دهد بین یک مدل هوش مصنوعی محلی (که روی کامپیوتر خودش با LM Studio اجرا می‌شود) و یک مدل ابری (مانند Gemini API) انتخاب کند.

**نقشه راه اجرایی:**

1.  ✅ **افزودن پکیج `http`:** برای ارسال درخواست به سرور محلی. (انجام شد)

2.  ✅ **ایجاد `blueprint.md`:** برای مستندسازی پروژه. (انجام شد)

3.  **ایجاد یک اینترفیس مشترک (`BaseAIService`):**
    - یک کلاس `abstract` تعریف می‌کنیم که متدهای اصلی مانند `sendMessage`, `askNarrator`, و `craftItems` را مشخص کند. این کار تضمین می‌کند که هر دو سرویس محلی و ابری ساختار یکسانی داشته باشند.

4.  **بازسازی سرویس ابری (`CloudAIService`):**
    - نام کلاس فعلی `AIService` را به `CloudAIService` تغییر می‌دهیم.
    - این کلاس، اینترفیس `BaseAIService` را پیاده‌سازی خواهد کرد.

5.  **ایجاد سرویس محلی (`LocalAIService`):**
    - یک کلاس جدید به نام `LocalAIService` می‌سازیم که اینترفیس `BaseAIService` را پیاده‌سازی کند.
    - این کلاس از پکیج `http` برای ارسال درخواست به سرور LM Studio (سازگار با OpenAI API) استفاده خواهد کرد.
    - منطق لازم برای مدیریت تاریخچه و پاک‌سازی پاسخ JSON مدل محلی در این کلاس قرار می‌گیرد.

6.  **طراحی صفحه تنظیمات:**
    - یک تب یا صفحه جدید برای "تنظیمات" ایجاد می‌شود.
    - در این صفحه، کاربر می‌تواند موارد زیر را پیکربندی کند:
      - **نوع ارائه‌دهنده AI:** انتخاب بین "محلی" و "ابری".
      - **آدرس سرور محلی:** فیلد متنی برای IP و پورت (مثال: `http://10.0.2.2:1234`).
      - **کلید API ابری:** فیلد متنی برای کلید API.
    - این تنظیمات باید روی دستگاه کاربر ذخیره شوند (با استفاده از `shared_preferences`).

7.  **ایجاد Provider داینامیک:**
    - `aiServiceProvider` فعلی را طوری بازنویسی می‌کنیم که به تنظیمات ذخیره شده کاربر گوش دهد.
    - بر اساس انتخاب کاربر، این Provider به صورت خودکار نمونه‌ای از `LocalAIService` یا `CloudAIService` را ایجاد و در اختیار بقیه برنامه قرار می‌دهد.

8.  **افزودن کامنت‌های فارسی:**
    - تمام کدهای جدید با کامنت‌های فارسی دقیق و جزئی مستندسازی خواهند شد.
